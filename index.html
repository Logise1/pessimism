<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Decisión</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para el juego */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .screen {
            display: none;
        }
        .screen.active {
            display: block;
        }
        /* Animación de entrada */
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Estilo para jugadores eliminados */
        .player-item.eliminated {
            text-decoration: line-through;
            opacity: 0.4;
            background-color: #374151; /* bg-gray-700 */
        }
        /* Indicador de voto (más sutil) */
        .player-item.voted::after {
            content: '■';
            color: #facc15; /* yellow-500 */
            font-size: 10px;
            margin-left: 8px;
            vertical-align: middle;
        }
    </style>
</head>
<body class="bg-black text-gray-300 min-h-screen flex items-center justify-center p-4">

    <!-- Contenedor principal del juego -->
    <div id="app-container" class="w-full max-w-lg mx-auto bg-gray-900 rounded-lg border border-gray-700 p-6 md:p-8">

        <!-- 1. Pantalla de Unirse (Join Screen) -->
        <div id="join-screen" class="screen active fade-in">
            <h1 class="text-3xl md:text-4xl font-black text-center mb-6">La Decisión</h1>
            <p class="text-center text-gray-500 mb-8">Solo puede quedar uno.</p>
            <div class="space-y-4">
                <input type="text" id="player-name" placeholder="Identificador" class="w-full p-3 bg-gray-800 text-white rounded-lg border border-gray-700 focus:outline-none focus:ring-2 focus:ring-red-500" maxlength="15">
                <input type="text" id="game-id-input" placeholder="ID de la Partida (para unirte)" class="w-full p-3 bg-gray-800 text-white rounded-lg border border-gray-700 focus:outline-none focus:ring-2 focus:ring-red-500" maxlength="5">
                <button id="join-button" class="w-full p-3 bg-gray-700 hover:bg-gray-600 rounded-lg font-bold text-lg transition-colors">Entrar</button>
                <button id="host-button" class="w-full p-3 bg-gray-700 hover:bg-gray-600 rounded-lg font-bold text-lg transition-colors">Iniciar Partida</button>
            </div>
            <p id="join-error" class="text-red-400 text-center mt-4"></p>
        </div>

        <!-- 2. Pantalla de Espera (Lobby Screen) -->
        <div id="lobby-screen" class="screen">
            <h2 class="text-2xl font-bold text-center mb-4">Sala de Contención</h2>
            <div class="bg-gray-800 border border-gray-700 p-4 rounded-lg text-center mb-6">
                <p class="text-gray-400">ID de la Partida:</p>
                <span id="game-id-display" class="text-3xl font-black text-red-500 tracking-widest font-mono">...</span>
            </div>
            <h3 class="font-bold text-lg mb-2">Participantes: <span id="lobby-player-count">0</span></h3>
            <ul id="lobby-player-list" class="bg-gray-800 rounded-lg p-4 space-y-2 min-h-[100px] border border-gray-700">
                <!-- Participantes se añadirán aquí dinámicamente -->
            </ul>
            <button id="start-button" class="w-full p-3 bg-yellow-600 hover:bg-yellow-700 text-black rounded-lg font-bold text-lg transition-colors mt-6">Comenzar Prueba</button>
        </div>

        <!-- 3. Pantalla de Juego (Game Screen) -->
        <div id="game-screen" class="screen">
            <div id="round-info" class="mb-4">
                <div class="flex justify-between text-lg mb-2">
                    <span class="text-gray-400">Prueba <span id="round-number">1</span></span>
                    <span class="text-yellow-500 font-bold">Vivos: <span id="game-survivors">0</span></span>
                </div>
                <div class="w-full bg-gray-700 rounded-full h-2.5">
                    <div id="timer-bar" class="bg-red-700 h-2.5 rounded-full transition-all duration-1000 linear"></div>
                </div>
            </div>

            <!-- Contenedor de la Frase -->
            <div id="phrase-container" class="bg-gray-800 border border-gray-700 p-6 rounded-lg min-h-[150px] flex items-center justify-center text-center mb-6">
                <p id="phrase-text" class="text-xl md:text-2xl font-medium">...</p>
            </div>

            <!-- Contenedor de Votación -->
            <div id="vote-container">
                <p class="text-center text-gray-400 mb-4">Toma tu decisión.</p>
                <div class="grid grid-cols-2 gap-4">
                    <button id="pessimist-button" class="p-4 bg-red-700 hover:bg-red-800 rounded-lg font-bold text-2xl transition-colors focus:outline-none focus:ring-2 focus:ring-red-400">Pesimista</button>
                    <button id="realist-button" class="p-4 bg-gray-600 hover:bg-gray-700 rounded-lg font-bold text-2xl transition-colors focus:outline-none focus:ring-2 focus:ring-gray-400">Realista</button>
                </div>
            </div>

            <!-- Contenedor de Espera -->
            <div id="wait-container" class="text-center p-6 bg-gray-800 rounded-lg border border-gray-700" style="display: none;">
                <p class="text-xl text-gray-400">Decisión registrada. Esperando...</p>
            </div>
        </div>

        <!-- 4. Pantalla de Resultados de Ronda -->
        <div id="results-screen" class="screen text-center">
            <h2 class="text-2xl font-bold mb-4">Evaluación</h2>
            <p class="text-lg mb-2">La respuesta correcta era:</p>
            <span id="correct-answer" class="text-3xl font-black uppercase mb-4 block">...</span>
            
            <div class="flex justify-around text-xl mb-4 p-4 bg-gray-800 rounded-lg border border-gray-700">
                <span class="text-green-500 font-bold">Vivos: <span id="results-survivors">0</span></span>
                <span class="text-red-500 font-bold">Eliminados: <span id="results-eliminated">0</span></span>
            </div>

            <p id="elimination-info" class="text-xl text-red-400 font-bold mb-4 h-12">...</p>
            <p class="text-gray-400">Siguiente prueba en <span id="next-round-timer">5</span>...</p>
        </div>

        <!-- 5. Pantalla de Fin de Juego -->
        <div id="game-over-screen" class="screen text-center">
            <h2 class="text-4xl font-black mb-6">PRUEBA FINALIZADA</h2>
            <p id="winner-info" class="text-2xl text-yellow-500 mb-8">...</p>
            <button id="play-again-button" class="w-full p-3 bg-yellow-600 hover:bg-yellow-700 text-black rounded-lg font-bold text-lg transition-colors mt-6">Reiniciar Protocolo</button>
        </div>

        <!-- Lista de Jugadores (Visible siempre durante el juego) -->
        <div id="player-list-container" class="mt-6" style="display: none;">
            <h3 class="font-bold text-sm text-gray-400 mb-2 text-center uppercase tracking-wider">Participantes</h3>
            <ul id="game-player-list" class="flex flex-wrap justify-center gap-2">
                <!-- Ejemplo: <li class="player-item bg-gray-800 p-2 px-3 rounded-full text-sm">Participante 1</li> -->
            </ul>
        </div>
    </div>

    <!-- Script de Firebase -->
    <script type="module">
        // Importaciones de Firebase v9+
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        // SE HAN ELIMINADO LAS IMPORTACIONES DE AUTH
        import { getDatabase, ref, set, get, onValue, update, remove } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";

        // CONFIGURACIÓN DE FIREBASE (proporcionada por el usuario)
        const firebaseConfig = {
            apiKey: "AIzaSyDrYwIMyL2y7yHXxQF4yjtokPOE2QyHC5I",
            authDomain: "pesimism-2fdad.firebaseapp.com",
            databaseURL: "https://pesimism-2fdad-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "pesimism-2fdad",
            storageBucket: "pesimism-2fdad.firebasestorage.app",
            messagingSenderId: "859660712236",
            appId: "1:859660712236:web:e09ac663d189f550d2d489",
            measurementId: "G-TYE4V0P8XB"
        };

        // BASE DE DATOS DE FRASES
        const PHRASE_LIST = [
            { text: "Todo va a salir mal.", type: "pesimista" },
            { text: "No tiene sentido intentarlo, fracasaré de todos modos.", type: "pesimista" },
            { text: "A veces las cosas no salen como planeas.", type: "realista" },
            { text: "El éxito requiere esfuerzo y asumir la posibilidad de fallar.", type: "realista" },
            { text: "Nunca se puede confiar en nadie.", type: "pesimista" },
            { text: "Es prudente ser cauteloso con en quién confías plenamente.", type: "realista" },
            { text: "La felicidad es solo una ilusión temporal.", type: "pesimista" },
            { text: "La felicidad es un estado emocional que fluctúa.", type: "realista" },
            { text: "El futuro es incierto y probablemente peor.", type: "pesimista" },
            { text: "El futuro es incierto y no se puede predecir.", type: "realista" },
            { text: "Da igual lo que hagas, el resultado será el mismo.", type: "pesimista" },
            { text: "No siempre puedes controlar el resultado, solo tu esfuerzo.", type: "realista" },
            { text: "La mayoría de la gente solo se preocupa por sí misma.", type: "realista" }, // Ambiguo
            { text: "Todo el mundo es fundamentalmente egoísta.", type: "pesimista" },
            { text: "No hay nada bueno en el mundo.", type: "pesimista" },
            { text: "El mundo tiene problemas significativos que deben abordarse.", type: "realista" },
            { text: "Siempre acabarás solo.", type: "pesimista" },
            { text: "Las relaciones requieren trabajo y no todas duran para siempre.", type: "realista" },
            { text: "Planificar es inútil porque todo se tuerce.", type: "pesimista" },
            { text: "Los planes deben ser flexibles para adaptarse a imprevistos.", type: "realista" }
        ];

        // Inicializar Firebase
        const app = initializeApp(firebaseConfig);
        // SE HA ELIMINADO LA INICIALIZACIÓN DE AUTH
        const db = getDatabase(app);

        // --- DECLARACIÓN DE ELEMENTOS DOM ---
        const playerNameInput = document.getElementById('player-name');
        const gameIdInput = document.getElementById('game-id-input');
        const joinButton = document.getElementById('join-button');
        const hostButton = document.getElementById('host-button');
        const joinError = document.getElementById('join-error');

        const gameIdDisplay = document.getElementById('game-id-display');
        const lobbyPlayerList = document.getElementById('lobby-player-list');
        const lobbyPlayerCount = document.getElementById('lobby-player-count');
        const startButton = document.getElementById('start-button');

        const roundNumber = document.getElementById('round-number');
        const gameSurvivors = document.getElementById('game-survivors');
        const phraseText = document.getElementById('phrase-text');
        const timerBar = document.getElementById('timer-bar');
        const voteContainer = document.getElementById('vote-container');
        const waitContainer = document.getElementById('wait-container');
        const pessimistButton = document.getElementById('pessimist-button');
        const realistButton = document.getElementById('realist-button');

        const correctAnswer = document.getElementById('correct-answer');
        const nextRoundTimer = document.getElementById('next-round-timer');
        const resultsSurvivors = document.getElementById('results-survivors');
        const resultsEliminated = document.getElementById('results-eliminated');
        const eliminationInfo = document.getElementById('elimination-info');

        const winnerInfo = document.getElementById('winner-info');
        const playAgainButton = document.getElementById('play-again-button');
        const gamePlayerList = document.getElementById('game-player-list');
        const playerListContainer = document.getElementById('player-list-container');

        // Screen elements
        const screens = document.querySelectorAll('.screen');


        // --- MANEJO DE ID DE USUARIO LOCAL ---
        // Se crea un ID local si no existe en la sesión
        function getOrCreateLocalUserId() {
            let uid = sessionStorage.getItem('pesimistaGameUserId');
            if (!uid) {
                uid = Math.random().toString(36).substring(2, 12); // Un ID aleatorio simple
                sessionStorage.setItem('pesimistaGameUserId', uid);
            }
            return uid;
        }

        // Variables de estado del juego
        let localUserId = getOrCreateLocalUserId(); // ID de usuario local en lugar de currentUser
        let currentGameId = null;
        let isHost = false;
        let localGameState = null;
        let gameTimerInterval = null;
        let isTickInProgress = false; // El bloqueo
        const ROUND_TIME = 15; // segundos
        const RESULTS_TIME = 5; // segundos
 
        // --- Helper function to show screens ---
        function showScreen(screenId) {
            // Ocultar todas las pantallas
            screens.forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Mostrar la pantalla activa
            const activeScreen = document.getElementById(`${screenId}-screen`);
            if (activeScreen) {
                activeScreen.classList.add('active', 'fade-in');
            }

            // Lógica para mostrar/ocultar la lista de jugadores
            if (screenId === 'game' || screenId === 'results' || screenId === 'gameOver') { // Añadido gameOver
                playerListContainer.style.display = 'block';
            } else {
                playerListContainer.style.display = 'none';
            }
        }

        // --- LÓGICA DE UNIRSE Y CREAR JUEGO ---

        hostButton.onclick = async () => {
            // El host ya no necesita nombre, solo crea la partida.
            if (!localUserId) {
                joinError.textContent = "Error de autenticación. Inténtalo de nuevo.";
                return;
            }

            isHost = true;
            currentGameId = Math.random().toString(36).substring(2, 7).toUpperCase();
            
            const gameRef = ref(db, `games/${currentGameId}`);
            
            const initialGameState = {
                status: 'lobby',
                hostId: localUserId, // Se usa localUserId
                players: {} // El host no es un jugador, la lista empieza vacía.
            };
            
            await set(gameRef, initialGameState);
            listenToGame(currentGameId);
        };

        joinButton.onclick = async () => {
            const name = playerNameInput.value.trim();
            const gameId = gameIdInput.value.trim().toUpperCase();

            if (!name) {
                joinError.textContent = "Por favor, introduce tu identificador.";
                return;
            }
            if (!gameId) {
                joinError.textContent = "Por favor, introduce un ID de partida.";
                return;
            }
            // Comprobación de localUserId en lugar de currentUser
            if (!localUserId) {
                joinError.textContent = "Error de autenticación. Inténtalo de nuevo.";
                return;
            }

            const gameRef = ref(db, `games/${gameId}`);
            const snapshot = await get(gameRef);

            if (!snapshot.exists()) {
                joinError.textContent = "Partida no encontrada.";
                return;
            }

            const gameData = snapshot.val();

            // Añadida comprobación de estado
            if (gameData.status !== 'lobby') {
                joinError.textContent = "Esta partida ya ha comenzado.";
                return;
            }

            const playerRef = ref(db, `games/${gameId}/players/${localUserId}`); // Se usa localUserId
            await set(playerRef, {
                name: name,
                isEliminated: false,
                vote: null
            });

            currentGameId = gameId;
            isHost = false; // Solo el creador es host
            listenToGame(gameId);
        };

        // --- LISTENER PRINCIPAL DEL JUEGO ---

        function listenToGame(gameId) {
            const gameRef = ref(db, `games/${gameId}`);
            onValue(gameRef, (snapshot) => {
                const state = snapshot.val();
                if (!state) {
                    // El juego fue borrado (quizás el host se fue)
                    console.log("La partida ha terminado o fue borrada.");
                    showScreen('join'); // Vuelve a la pantalla de inicio
                    // Resetea el estado local
                    currentGameId = null;
                    isHost = false;
                    localGameState = null;
                    if(gameTimerInterval) {
                        clearTimeout(gameTimerInterval);
                        gameTimerInterval = null;
                    }
                    joinError.textContent = "La partida ha terminado o fue borrada.";
                    return;
                }
                
                localGameState = state; // Actualizar estado local
                updateUI(state);

                // El host maneja la lógica del juego
                if (isHost && localUserId === state.hostId) { // Se usa localUserId
                    handleHostLogic(state);
                }
            });
        }

        // --- ACTUALIZACIÓN DE LA UI ---

        function updateUI(state) {
            const players = state.players || {};
            const playerArray = Object.entries(players).map(([id, data]) => ({ id, ...data }));
            const activePlayers = playerArray.filter(p => !p.isEliminated);
            const eliminatedPlayers = playerArray.filter(p => p.isEliminated);
            
            // Actualizar estado de pantalla
            if (state.status === 'lobby') {
                showScreen('lobby');
                gameIdDisplay.textContent = currentGameId;
                lobbyPlayerList.innerHTML = playerArray.map(p => `<li class="p-2">${p.name}</li>`).join('');
                lobbyPlayerCount.textContent = playerArray.length;
                startButton.style.display = (isHost && playerArray.length > 0) ? 'block' : 'none';
            
            } else if (state.status === 'playing') {
                if (state.showResults) {
                    showScreen('results');
                    correctAnswer.textContent = state.currentPhrase.type;
                    nextRoundTimer.textContent = state.timer;
                    resultsSurvivors.textContent = activePlayers.length;
                    resultsEliminated.textContent = eliminatedPlayers.length;
                    
                    const eliminatedThisRound = playerArray.filter(p => p.justEliminated);
                    if (eliminatedThisRound.length > 0) {
                        eliminationInfo.textContent = `Eliminados: ${eliminatedThisRound.map(p => p.name).join(', ')}`;
                    } else {
                        eliminationInfo.textContent = "Nadie ha sido eliminado. Por ahora.";
                    }

                } else {
                    showScreen('game');
                    roundNumber.textContent = state.currentRound;
                    gameSurvivors.textContent = activePlayers.length;
                    phraseText.textContent = state.currentPhrase.text;
                    
                    // Barra de tiempo
                    const timerPercentage = (state.timer / ROUND_TIME) * 100;
                    timerBar.style.width = `${timerPercentage}%`;

                    // Lógica de votación (diferente para Host y Jugadores)
                    const myData = players[localUserId]; // Se usa localUserId

                    if (isHost) {
                        // El Host (proyector) no vota, solo observa.
                        voteContainer.style.display = 'none';
                        waitContainer.style.display = 'block';
                        waitContainer.firstElementChild.textContent = "Prueba en curso... Esperando decisiones.";
                    
                    } else if (myData) { // Comprobar si myData existe (es un jugador)
                        if (myData.isEliminated) {
                            voteContainer.style.display = 'none';
                            waitContainer.style.display = 'block';
                            waitContainer.firstElementChild.textContent = "PARTICIPANTE ELIMINADO.";
                        } else if (myData.vote) {
                            voteContainer.style.display = 'none';
                            waitContainer.style.display = 'block';
                            waitContainer.firstElementChild.textContent = "Decisión registrada. Esperando...";
                        } else {
                            voteContainer.style.display = 'block';
                            waitContainer.style.display = 'none';
                        }
                    } else {
                        // Es un espectador o alguien que no se unió a tiempo
                        voteContainer.style.display = 'none';
                        waitContainer.style.display = 'block';
                        waitContainer.firstElementChild.textContent = "Observando...";
                    }
                }

            } else if (state.status === 'finished') {
                showScreen('gameOver');
                if (activePlayers.length === 1) {
                    winnerInfo.textContent = `Superviviente: ${activePlayers[0].name}`;
                } else if (activePlayers.length > 1) {
                     // Esto ya no debería pasar, pero se mantiene como fallback
                     winnerInfo.textContent = `Supervivientes: ${activePlayers.map(p => p.name).join(', ')}`;
                } else {
                    // Ahora es un resultado oficial
                    winnerInfo.textContent = "NADIE HA SUPERADO LA PRUEBA.";
                }
                playAgainButton.style.display = isHost ? 'block' : 'none';
            }

            // Actualizar lista de jugadores persistente
            gamePlayerList.innerHTML = playerArray.map(p => {
                let classes = "player-item p-2 px-3 rounded-full text-sm transition-all";
                classes += p.isEliminated ? " eliminated" : " bg-gray-800 border border-gray-700";
                
                // Mostrar borde de voto solo en resultados
                if (state.showResults && !p.isEliminated) {
                    classes += (p.vote === state.currentPhrase.type) ? " border-2 border-green-500" : " border-2 border-red-500";
                }
                // Mostrar indicador de "ha votado" antes de los resultados
                if (!state.showResults && p.vote && !p.isEliminated) {
                    classes += " voted";
                }
                
                return `<li class="${classes}">${p.name}</li>`;
            }).join('');
        }

        // --- LÓGICA DEL HOST (MANEJO DEL JUEGO) ---

        startButton.onclick = () => {
            if (!isHost) return;

            const shuffledPhrases = [...PHRASE_LIST].sort(() => Math.random() - 0.5);
            const initialPlayers = { ...localGameState.players };
            Object.keys(initialPlayers).forEach(id => {
                initialPlayers[id].isEliminated = false;
                initialPlayers[id].vote = null;
            });

            const gameRef = ref(db, `games/${currentGameId}`);
            update(gameRef, {
                status: 'playing',
                currentRound: 1,
                phrases: shuffledPhrases,
                currentPhrase: shuffledPhrases[0],
                timer: ROUND_TIME,
                showResults: false,
                players: initialPlayers
            });
        };

        function handleHostLogic(state) {
            // Iniciar o detener el temporizador
            if (state.status === 'playing' && !gameTimerInterval && !isTickInProgress) {
                console.log("Iniciando bucle de timer");
                // --- INICIO DE LA CORRECCIÓN ---
                // Pasa el estado MÁS RECIENTE al primer tick
                handleGameTick(state); 
                // --- FIN DE LA CORRECCIÓN ---
            } else if (state.status !== 'playing' && gameTimerInterval) {
                console.log("Cancelando bucle de timer");
                clearTimeout(gameTimerInterval);
                gameTimerInterval = null;
            }
        }

        // --- INICIO DE LA CORRECCIÓN ---
        // La función ahora acepta el estado para forzar la frescura en el primer tick
        async function handleGameTick(passedState) {
            // El primer tick usa 'passedState' (fresco), los siguientes usan 'localGameState' (global)
            const stateToUse = passedState || localGameState;
            // --- FIN DE LA CORRECCIÓN ---

            // Comprobación de seguridad
            // --- CORRECCIÓN: Usar stateToUse ---
            if (!isHost || !stateToUse || stateToUse.status !== 'playing') {
                console.log("Tick: Deteniendo (no host o juego no en curso)");
                isTickInProgress = false;
                gameTimerInterval = null;
                return; // Detener el bucle
            }

            // Bloqueo
            if (isTickInProgress) {
                console.log("Tick: Omitido (tick anterior en progreso)");
                return;
            }
            isTickInProgress = true;
            // --- CORRECCIÓN: Usar stateToUse ---
            console.log("Tick: Iniciado", stateToUse.timer);

            // Lógica del tick
            const gameRef = ref(db, `games/${currentGameId}`);
            // --- CORRECCIÓN: Usar stateToUse ---
            let newTimer = stateToUse.timer - 1;

            try {
                // --- CORRECCIÓN: Usar stateToUse ---
                if (stateToUse.showResults) {
                    // Estamos en la pantalla de resultados
                    if (newTimer <= 0) {
                        console.log("Tick: Siguiente ronda");
                        // --- CORRECCIÓN: Pasar estado ---
                        await nextRound(stateToUse);
                    } else {
                        console.log("Tick: Actualizando timer (resultados)");
                        await update(gameRef, { timer: newTimer });
                    }
                } else {
                    // Estamos en la pantalla de votación
                    // --- CORRECCIÓN: Usar stateToUse ---
                    const players = stateToUse.players || {};
                    const activePlayers = Object.values(players).filter(p => !p.isEliminated);
                    
                    const allVoted = activePlayers.length > 0 && activePlayers.every(p => p.vote !== null);

                    if (newTimer <= 0 || allVoted) {
                        // Calcular resultados
                        console.log("Tick: Calculando resultados");
                        // --- CORRECCIÓN: Pasar estado ---
                        await calculateResults(stateToUse);
                    } else {
                        // Actualizando timer (juego)
                        console.log("Tick: Actualizando timer (juego)");
                        await update(gameRef, { timer: newTimer });
                    }
                }
            } catch (error) {
                console.error("Error durante el tick:", error);
            }

            // Quitar el bloqueo ANTES de programar el siguiente
            isTickInProgress = false; 

            // Programar siguiente tick
            // Leer el estado global MÁS RECIENTE (actualizado por onValue)
            // para decidir si continuar.
            if (localGameState.status === 'playing') {
                console.log("Tick: Programando siguiente tick");
                // El siguiente tick SÍ usará el global 'localGameState'
                gameTimerInterval = setTimeout(handleGameTick, 1000);
            } else {
                console.log("Tick: Fin del juego, no más ticks");
                gameTimerInterval = null;
            }
        }
 
        // --- CORRECCIÓN: La función ahora acepta el estado ---
        async function calculateResults(state) {
            const players = { ...state.players };
            const correctAnswer = state.currentPhrase.type;
            let eliminatedCount = 0;
            
            const activePlayerIds = Object.keys(players).filter(id => !players[id].isEliminated);
            // Los que votan null (se acaba el tiempo) también son eliminados
            const wrongPlayerIds = activePlayerIds.filter(id => players[id].vote !== correctAnswer);
            
            // Lógica de eliminación:
            // Si te equivocas, estás eliminado.
            if (wrongPlayerIds.length > 0) {
                eliminatedCount = wrongPlayerIds.length;
                wrongPlayerIds.forEach(id => {
                    players[id].isEliminated = true;
                    players[id].justEliminated = true; // Flag temporal
                });
            }

            // Limpiar flags temporales
            Object.keys(players).forEach(id => {
                if (!wrongPlayerIds.includes(id)) {
                    players[id].justEliminated = false;
                }
            });

            const activePlayersLeft = activePlayerIds.length - eliminatedCount;
            let newStatus = 'playing';
            if (activePlayersLeft <= 1) { // <= 1 (cubre 0 o 1 supervivientes)
                newStatus = 'finished';
            }

            await update(ref(db, `games/${currentGameId}`), {
                status: newStatus,
                showResults: true,
                timer: RESULTS_TIME,
                players: players
            });
        }

        // --- CORRECCIÓN: La función ahora acepta el estado ---
        async function nextRound(state) {
            let newRound = state.currentRound + 1;
            let phrases = state.phrases;
            
            // Si el estado es 'finished' (0 o 1 jugador), termina.
            if (state.status === 'finished') {
                await update(ref(db, `games/${currentGameId}`), { status: 'finished' });
                return;
            }

            // Si nos quedamos sin frases, pero el juego NO ha terminado...
            if (newRound > phrases.length) {
                // Baraja de nuevo y empieza un "nuevo ciclo"
                console.log("Re-barajando frases");
                newRound = 1;
                phrases = [...PHRASE_LIST].sort(() => Math.random() - 0.5);
            }

            const players = { ...state.players };
            Object.keys(players).forEach(id => {
                players[id].vote = null; // Resetear votos
                players[id].justEliminated = false; // Limpiar flag
            });

            await update(ref(db, `games/${currentGameId}`), {
                currentRound: newRound,
                currentPhrase: phrases[newRound - 1],
                phrases: phrases, // Guarda la nueva lista barajada si es el caso
                timer: ROUND_TIME,
                showResults: false,
                players: players
            });
        }

        // --- ACCIONES DEL JUGADOR ---

        pessimistButton.onclick = () => submitVote('pesimista');
        realistButton.onclick = () => submitVote('realista');

        function submitVote(vote) {
            if (!currentGameId || !localUserId) return;
            if (!localGameState || !localGameState.players) return; 
            const myData = localGameState.players[localUserId];
            
            if (!myData || myData.isEliminated || myData.vote) return; // No votar si ya votó o está eliminado

            const voteRef = ref(db, `games/${currentGameId}/players/${localUserId}/vote`);
            set(voteRef, vote);
        }
 
        // --- FIN DEL JUEGO / REINICIAR ---

        playAgainButton.onclick = async () => {
            if (!isHost) return;
            
            // Resetear el estado del juego a la sala de espera
            const players = { ...localGameState.players };
            Object.keys(players).forEach(id => {
                players[id].isEliminated = false;
                players[id].vote = null;
                players[id].justEliminated = false;
            });

            await set(ref(db, `games/${currentGameId}`), {
                status: 'lobby',
                hostId: localUserId,
                players: players
            });
        };

        // Limpieza al cerrar la pestaña (opcional pero bueno)
        window.addEventListener('beforeunload', () => {
            if (!currentGameId || !localUserId) return;

            const playerRef = ref(db, `games/${currentGameId}/players/${localUserId}`);
            
            // Solo quitar al jugador si no es el host.
            if (!isHost) {
                remove(playerRef); // Quitar al jugador
            }

            if (isHost) {
                // Si el host se va, borrar el juego
                const gameRef = ref(db, `games/${currentGameId}`);
                remove(gameRef);
            }
        });

    </script>
</body>
</html>
