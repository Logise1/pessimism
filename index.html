<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Prueba</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para el tema oscuro */
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'Roboto Mono', monospace;
        }
        
        /* Efecto de "glitch" sutil para el texto eliminado */
        .text-eliminado {
            color: #ef4444; /* red-500 */
            text-decoration: line-through;
            animation: glitch 0.3s linear infinite;
        }

        /* Animación de aparición */
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Animación de pulso para eventos */
        .animate-pulse {
            animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }


        /* Estilo de botones base */
        .btn {
            @apply w-full px-6 py-4 text-lg font-bold uppercase border-2 rounded-md transition-all duration-300 focus:outline-none focus:ring-4 focus:ring-opacity-50;
        }

        .btn-primary {
            @apply bg-white text-black border-white hover:bg-gray-200 focus:ring-white;
        }

        .btn-danger {
            @apply text-red-500 border-red-500 hover:bg-red-500 hover:text-black focus:ring-red-500;
        }

        .btn-secondary {
             @apply text-gray-400 border-gray-400 hover:bg-gray-400 hover:text-black focus:ring-gray-400;
        }

        .btn-disabled {
            @apply text-gray-700 border-gray-700 bg-gray-900 cursor-not-allowed;
        }

        /* Estilo para listas de jugadores */
        .player-list-item {
            @apply px-4 py-2 bg-gray-900 border border-gray-700 rounded-md text-gray-300;
        }
        .player-list-item.survivor {
            @apply border-green-500 text-green-400;
        }
        .player-list-item.eliminated {
            @apply border-red-500 text-red-500 line-through;
        }

    </style>
</head>
<body class="bg-black text-gray-200 min-h-screen flex items-center justify-center p-4">

    <!-- Contenedor principal de la aplicación -->
    <div id="app" class="w-full max-w-4xl mx-auto">
        <!-- Esta pantalla se sobrescribirá con JavaScript -->
        <div class="text-center">
            <h1 class="text-3xl font-bold text-white mb-6">INICIANDO SISTEMA...</h1>
            <p class="text-gray-500">Estableciendo conexión...</p>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Importar funciones de Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        // Se elimina la importación de 'auth'
        import { getDatabase, ref, onValue, set, update, onDisconnect, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

        // --- CONFIGURACIÓN DE FIREBASE (PROPORCIONADA POR EL USUARIO) ---
        const firebaseConfig = {
            apiKey: "AIzaSyDrYwIMyL2y7yHXxQF4yjtokPOE2QyHC5I",
            authDomain: "pesimism-2fdad.firebaseapp.com",
            databaseURL: "https://pesimism-2fdad-default-rtdb.europe-west1.firebasedatabase.app", // Corregido el error tipográfico
            projectId: "pesimism-2fdad",
            storageBucket: "pesimism-2fdad.firebasestorage.app",
            messagingSenderId: "859660712236",
            appId: "1:859660712236:web:e09ac663d189f550d2d489",
            measurementId: "G-TYE4V0P8XB"
        };
        
        // --- BANCO DE FRASES REESTRUCTURADO POR DIFICULTAD ---
        // 'r' = Realista, 'p' = Pesimista

        // Súper obvias
        const PHRASES_EASY = [
            { text: "El sol saldrá mañana, sin importar lo que pase hoy.", answer: 'r' },
            { text: "Todas las personas cometen errores.", answer: 'r' },
            { text: "El pasado no se puede cambiar.", answer: 'r' },
            { text: "Las cosas materiales no duran para siempre.", answer: 'r' },
            { text: "El cuerpo humano envejece y eventualmente falla.", answer: 'r' },
            { text: "Cualquier cosa que pueda salir mal, saldrá mal.", answer: 'p' }, // Famosa ley pesimista
            { text: "Las cosas nunca mejorarán.", answer: 'p' }, // Pesimismo obvio
            { text: "Nunca serás verdaderamente feliz.", answer: 'p' }, // Pesimismo absoluto
            { text: "No importa lo que hagas, al final fracasarás.", answer: 'p' },
        ];

        // Requieren pensar un poco
        const PHRASES_MEDIUM = [
            { text: "Confiar ciegamente en desconocidos te hace vulnerable.", answer: 'r' },
            { text: "Nadie consigue todo lo que quiere en la vida.", answer: 'r' },
            { text: "No le puedes caer bien a todo el mundo.", answer: 'r' },
            { text: "El trabajo duro no siempre garantiza el éxito.", answer: 'r' },
            { text: "No siempre obtienes lo que mereces.", answer: 'r' },
            { text: "Los recursos naturales del planeta son finitos.", answer: 'r' },
            { text: "Las estadísticas de accidentes aumentan significativamente durante los días festivos.", answer: 'r' },
            { text: "Toda buena racha está destinada a terminarse.", answer: 'p' },
            { text: "La gente te decepcionará en cuanto tenga la oportunidad.", answer: 'p' },
            { text: "Es mejor no esperar nada para nunca sentirse decepcionado.", answer: 'p' },
            { text: "Si algo parece demasiado bueno para ser verdad, seguro es mentira.", answer: 'p' },
            { text: "La gente solo te ayuda si puede obtener algo a cambio.", answer: 'p' },
        ];

        // Difíciles (Sutiles, filosóficas, pero no ambiguas)
        const PHRASES_HARD = [
            { text: "La felicidad es un estado químico temporal en el cerebro.", answer: 'r' }, // Hecho científico que se siente pesimista
            { text: "La historia humana está definida por el conflicto, no por la paz.", answer: 'r' }, // Hecho histórico observable
            { text: "No puedes controlar las acciones o sentimientos de otras personas.", answer: 'r' }, // Verdad fundamental
            { text: "Incluso las decisiones mejor informadas pueden tener resultados negativos.", answer: 'r' }, // Realismo estadístico
            { text: "Un pequeño porcentaje de la población controla la mayoría de los recursos globales.", answer: 'r' }, // Hecho estadístico
            { text: "La memoria humana es inherentemente poco fiable.", answer: 'r' }, // Hecho psicológico
            { text: "La gente siempre actuará en su propio interés, incluso a costa tuya.", answer: 'p' }, // Generalización negativa absoluta
            { text: "Todo esfuerzo es, en última instancia, inútil frente a la inmensidad del tiempo.", answer: 'p' }, // Pesimismo filosófico
            { text: "Al final, estás fundamentalmente solo.", answer: 'p' }, // Pesimismo existencial
            { text: "Cualquier acto de bondad esconde un motivo egoísta.", answer: 'p' }, // Cinismo absoluto
            { text: "El mundo es injusto por naturaleza y siempre lo será.", answer: 'p' }, // Declaración fatalista
            { text: "Tus logros serán olvidados.", answer: 'p' }, // Proyección negativa
        ];
        
        // Se elimina la constante 'PHRASES' única


        // --- VARIABLES GLOBALES ---
        const app = initializeApp(firebaseConfig);
        // Se elimina la const 'auth'
        const db = getDatabase(app);
        
        let localUserId = null; // Reemplaza a userId de auth
        let isHost = false;
        let gameState = {}; // Caché local del estado del juego
        
        const appElement = document.getElementById('app');
        const gameRef = ref(db, 'la-prueba/game');
        const hostIdRef = ref(db, 'la-prueba/hostId');

        // --- FUNCIÓN PRINCIPAL ---
        function main() {
            // Ya no usamos onAuthStateChanged
            // Intentar recuperar un ID local, o crear uno nuevo
            localUserId = localStorage.getItem('laPruebaUserId') || crypto.randomUUID();
            localStorage.setItem('laPruebaUserId', localUserId); 

            console.log("Sesión local iniciada con ID:", localUserId);
            renderInitialScreen();
        }

        // --- FUNCIONES DE RENDERIZADO (VISTAS) ---

        // Escapar HTML para evitar XSS
        function escapeHTML(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/[&<>"']/g, function(m) {
                return {
                    '&': '&amp;',
                    '<': '&lt;',
                    '>': '&gt;',
                    '"': '&quot;',
                    "'": '&#39;'
                }[m];
            });
        }

        // 1. Pantalla Inicial (Selección de Rol)
        function renderInitialScreen() {
            appElement.innerHTML = `
                <div class="text-center fade-in">
                    <h1 class="text-4xl font-bold text-white mb-8">[ LA PRUEBA ]</h1>
                    <p class="text-gray-400 mb-12">Elige tu rol. Solo puede haber un presentador.</p>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 max-w-lg mx-auto">
                        <button id="hostBtn" class="btn btn-danger">Modo Presentador</button>
                        <button id="playerBtn" class="btn btn-secondary">Modo Jugador</button>
                    </div>
                </div>
            `;
            document.getElementById('hostBtn').addEventListener('click', joinAsHost);
            document.getElementById('playerBtn').addEventListener('click', joinAsPlayer);
        }

        // 2. Vistas del HOST
        function renderHostLobby(players) {
            const playerCount = Object.keys(players).length;
            appElement.innerHTML = `
                <div class="text-center fade-in">
                    <h1 class="text-3xl font-bold text-red-500 mb-6">SALA DE ESPERA</h1>
                    <p class="text-gray-400 mb-8">Esperando jugadores. Proyecta esta pantalla.</p>
                    <div class="max-w-md mx-auto mb-8">
                        <h2 class="text-xl text-white mb-4">Jugadores Conectados: ${playerCount}</h2>
                        <div id="player-list" class="space-y-2 max-h-60 overflow-y-auto">
                            ${Object.values(players).map(p => 
                                `<div class="player-list-item">${escapeHTML(p.name)}</div>`
                            ).join('')}
                        </div>
                    </div>
                    <button id="startBtn" class="btn btn-primary w-auto mx-auto" ${playerCount === 0 ? 'disabled' : ''}>
                        Comenzar la Prueba
                    </button>
                </div>
            `;
            document.getElementById('startBtn').addEventListener('click', startNextRound);
        }
        
        function renderHostRound(phrase, players) {
            const survivors = Object.values(players).filter(p => !p.isEliminated);
            const votes = survivors.filter(p => p.vote).length;
            const votePercentage = survivors.length > 0 ? (votes / survivors.length) * 100 : 0;
            const isSuddenDeath = gameState.specialEvent === 'sudden_death';

            // --- INICIO DE RENDERIZADO INTELIGENTE ---
            // Si ya estamos en esta vista, solo actualiza los datos dinámicos
            const voteCounter = document.getElementById('vote-counter');
            const phraseTextElement = document.getElementById('phrase-text');

            // Comprobar si la frase es la misma para evitar re-renderizado
            if (voteCounter && phraseTextElement && phraseTextElement.dataset.text === phrase.text) {
                voteCounter.textContent = `Votos recibidos: ${votes} / ${survivors.length}`;
                document.getElementById('vote-progress-bar').style.width = `${votePercentage}%`;
                return; // No re-renderizar todo, evita que la animación "fade-in" se repita
            }
            // --- FIN DE RENDERIZADO INTELIGENTE ---

            // Renderizado completo si es una nueva ronda
            appElement.innerHTML = `
                <div class="text-center fade-in max-w-3xl mx-auto">
                    <p class="text-gray-500 text-lg mb-4">Ronda ${gameState.currentRound + 1}</p>
                    
                    ${isSuddenDeath ? `<h2 class="text-5xl font-bold text-red-700 mb-6 animate-pulse">¡MUERTE SÚBITA!</h2>` : ''}

                    <h1 id="phrase-text" data-text="${escapeHTML(phrase.text)}" class="text-4xl font-bold text-white mb-12 leading-relaxed">
                        "${escapeHTML(phrase.text)}"
                    </h1>

                    ${isSuddenDeath ? 
                        `<p class="text-2xl text-red-400 mb-8">¡Fallar esta ronda significa la eliminación instantánea!</p>` : 
                        `<h2 class="text-2xl text-gray-400 mb-8">¿Pesimista o Realista?</h2>`
                    }
                    
                    <p id="vote-counter" class="text-xl text-white mb-4">Votos recibidos: ${votes} / ${survivors.length}</p>
                    <div class="w-full bg-gray-800 rounded-full h-2.5 mb-8">
                        <div id="vote-progress-bar" class="bg-green-500 h-2.5 rounded-full transition-all duration-300" style="width: ${votePercentage}%"></div>
                    </div>
                    <button id="revealBtn" class="btn btn-danger w-auto mx-auto">
                        Finalizar Ronda y Revelar
                    </button>
                </div>
            `;
            document.getElementById('revealBtn').addEventListener('click', revealAnswers);
        }

        function renderHostReveal(phrase, players, answer) {
            const survivors = Object.values(players).filter(p => !p.isEliminated);
            const eliminated = Object.values(players).filter(p => p.isEliminated);
            const isGameOver = survivors.length <= 1;

            appElement.innerHTML = `
                <div class="text-center fade-in max-w-4xl mx-auto">
                    <h1 class="text-4xl font-bold mb-6 ${answer === 'r' ? 'text-green-500' : 'text-red-500'}">
                        La respuesta era: ${answer === 'r' ? 'REALISTA' : 'PESIMISTA'}
                    </h1>
                    <p class="text-2xl text-white mb-10">"${escapeHTML(phrase.text)}"</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <h2 class="text-2xl text-green-500 font-bold mb-4">SOBREVIVIENTES (${survivors.length})</h2>
                            <div class="space-y-2 max-h-60 overflow-y-auto">
                                ${survivors.map(p => `<div class="player-list-item survivor">${escapeHTML(p.name)} (Vidas: ${p.lives ?? 0})</div>`).join('')}
                            </div>
                        </div>
                        <div>
                            <h2 class="text-2xl text-red-500 font-bold mb-4">ELIMINADOS (${eliminated.length})</h2>
                            <div class="space-y-2 max-h-60 overflow-y-auto">
                                ${eliminated.map(p => `<div class="player-list-item eliminated">${escapeHTML(p.name)}</div>`).join('')}
                            </div>
                        </div>
                    </div>

                    <button id="nextBtn" class="btn btn-primary w-auto mx-auto mt-12">
                        ${isGameOver ? 'Finalizar Juego' : 'Siguiente Ronda'}
                    </button>
                </div>
            `;
            document.getElementById('nextBtn').addEventListener('click', isGameOver ? triggerGameOver : startNextRound);
        }
        
        function renderHostGameOver(winnerName) {
            appElement.innerHTML = `
                <div class="text-center fade-in">
                    <h1 class="text-5xl font-bold text-white mb-6">LA PRUEBA HA TERMINADO</h1>
                    ${winnerName ? 
                        `<p class="text-3xl text-green-400 mb-12">Ganador: ${escapeHTML(winnerName)}</p>` :
                        `<p class="text-3xl text-red-500 mb-12">Nadie ha sobrevivido.</p>`
                    }
                    <button id="resetBtn" class="btn btn-danger w-auto mx-auto">
                        Reiniciar Sala
                    </button>
                </div>
            `;
            document.getElementById('resetBtn').addEventListener('click', initGame);
        }


        // 3. Vistas del JUGADOR
        function renderPlayerLobby(players) {
            const myName = players[localUserId]?.name || localStorage.getItem('laPruebaPlayerName') || "Invitado"; // Usa localUserId
            appElement.innerHTML = `
                <div class="text-center fade-in max-w-md mx-auto">
                    <h1 class="text-3xl font-bold text-white mb-4">SALA DE ESPERA</h1>
                    <p class="text-lg text-gray-400 mb-8">Conectado como: <span class="text-green-400">${escapeHTML(myName)}</span></p>
                    <p class="text-2xl text-gray-200">Esperando que el presentador inicie la prueba...</p>
                    <div class="mt-8">
                        <h3 class="text-lg text-gray-500 mb-3">Otros jugadores:</h3>
                        <div class="space-y-2 max-h-40 overflow-y-auto">
                            ${Object.values(players).filter(p => p.id !== localUserId).map(p => // Usa localUserId
                                `<div class="player-list-item">${escapeHTML(p.name)}</div>`
                            ).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function renderPlayerVote(phrase) {
            const isSuddenDeath = gameState.specialEvent === 'sudden_death';
            appElement.innerHTML = `
                <div class="text-center fade-in max-w-2xl mx-auto">
                    <p class="text-gray-500 text-lg mb-4">Ronda ${gameState.currentRound + 1}</p>
                    
                    ${isSuddenDeath ? `<h2 class="text-4xl font-bold text-red-700 mb-6 animate-pulse">¡MUERTE SÚBITA!</h2>` : ''}

                    <h1 class="text-3xl font-bold text-white mb-10 leading-relaxed">
                        "${escapeHTML(phrase.text)}"
                    </h1>

                    ${isSuddenDeath ? 
                        `<p class="text-xl text-red-400 mb-8">Si fallas, pierdes todas tus vidas.</p>` : 
                        `<p class="text-xl text-gray-300 mb-8">Tu decisión:</p>`
                    }

                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-6">
                        <button id="voteP" class="btn btn-danger">Pesimista</button>
                        <button id="voteR" class="btn btn-secondary">Realista</button>
                    </div>
                </div>
            `;
            document.getElementById('voteP').addEventListener('click', () => handleVote('p'));
            document.getElementById('voteR').addEventListener('click', () => handleVote('r'));
        }

        function renderPlayerWait(message) {
            appElement.innerHTML = `
                <div class="text-center fade-in max-w-md mx-auto">
                    <h1 class="text-3xl font-bold text-white mb-8">${escapeHTML(message)}</h1>
                    <p class="text-2xl text-gray-400">Esperando al presentador...</p>
                </div>
            `;
        }
        
        function renderPlayerResult(isCorrect, lives) {
             const lifeMessage = isCorrect ? 
                'Sobrevives... por ahora.' : 
                (lives > 0 ? `Has perdido una vida. Te quedan ${lives}.` : 'Un error te cuesta todo.');

             appElement.innerHTML = `
                <div class="text-center fade-in max-w-md mx-auto">
                    <h1 class="text-5xl font-bold ${isCorrect ? 'text-green-500' : 'text-red-500'} mb-8">
                        ${isCorrect ? 'CORRECTO' : 'INCORRECTO'}
                    </h1>
                    <p class="text-2xl text-gray-300">
                        ${lifeMessage}
                    </p>
                    <p class="text-xl text-gray-500 mt-10">Esperando la siguiente ronda...</p>
                </div>
            `;
        }
        
        function renderPlayerEliminated() {
            appElement.innerHTML = `
                <div class="text-center fade-in max-w-md mx-auto">
                    <h1 class="text-6xl font-bold text-red-700 mb-8">ELIMINADO</h1>
                    <p class="text-2xl text-gray-500">
                        Observa en silencio.
                    </p>
                </div>
            `;
        }

        function renderPlayerGameOver(winnerName) {
            appElement.innerHTML = `
                <div class="text-center fade-in">
                    <h1 class="text-5xl font-bold text-white mb-6">LA PRUEBA HA TERMINADO</h1>
                    ${winnerName ? 
                        `<p class="text-3xl text-green-400 mb-12">Ganador: ${escapeHTML(winnerName)}</p>` :
                        `<p class="text-3xl text-red-500 mb-12">Nadie ha sobrevivido.</p>`
                    }
                    <p class="text-gray-500">Puedes cerrar esta ventana.</p>
                </div>
            `;
        }


        // --- LÓGICA DEL JUEGO (HOST) ---
        
        function joinAsHost() {
            isHost = true;
            console.log("Intentando unirse como Host");
            
            // Comprobar si ya hay un host
            onValue(hostIdRef, (snapshot) => {
                const currentHostId = snapshot.val();
                // Si hay un host Y ese host NO soy yo, no puedo ser host
                if (currentHostId && currentHostId !== localUserId) {
                    // Usar un modal custom en lugar de alert
                    renderInitialScreen(); // Volver a la pantalla inicial
                    // Inyectar un mensaje de error
                    const title = document.querySelector("#app h1");
                    if(title) {
                        const errorMsg = document.createElement('p');
                        errorMsg.className = 'text-red-500 text-lg mb-4';
                        errorMsg.textContent = '¡Error! Ya hay un presentador en esta sala. Únete como jugador.';
                        title.parentNode.insertBefore(errorMsg, title.nextSibling);
                    }
                    isHost = false;
                } else {
                    // No hay host, o el host soy yo (refresqué la página)
                    // Tomar control como host
                    set(hostIdRef, localUserId); 
                    onDisconnect(hostIdRef).remove(); // Si me voy, dejo el puesto libre
                    
                    // No reiniciamos el juego, solo nos conectamos a él
                    setupHostListener();
                }
            }, { onlyOnce: true }); // Solo comprobar una vez
        }

        // Inicializa o resetea el juego
        function initGame() {
            console.log("INICIALIZANDO JUEGO NUEVO CON DIFICULTAD PROGRESIVA");
            
            // 1. Barajar cada categoría de dificultad por separado
            const shuffledEasy = [...PHRASES_EASY].sort(() => Math.random() - 0.5);
            const shuffledMedium = [...PHRASES_MEDIUM].sort(() => Math.random() - 0.5);
            const shuffledHard = [...PHRASES_HARD].sort(() => Math.random() - 0.5);

            // 2. Concatenarlas en orden de dificultad
            const finalShuffledList = [...shuffledEasy, ...shuffledMedium, ...shuffledHard];

            set(gameRef, {
                state: 'lobby',
                players: {},
                currentRound: -1,
                currentPhrase: null,
                // Reemplaza 'shuffledPhraseIndices' con la lista de frases completa
                shuffledPhrases: finalShuffledList, 
                specialEvent: null,
                winner: null
            });
        }

        // El Host inicia la siguiente ronda
        function startNextRound() {
            const currentRound = gameState.currentRound + 1;
            // Obtener la frase directamente de la lista ordenada en Firebase
            const newPhrase = gameState.shuffledPhrases[currentRound];

            if (typeof newPhrase === 'undefined') {
                // Se acabaron las frases
                triggerGameOver();
                return;
            }

            // const newPhrase = PHRASES[phraseIndex]; // Línea eliminada
            
            // Resetear votos de jugadores no eliminados
            const players = gameState.players || {};
            const updates = {};
            Object.keys(players).forEach(pid => {
                if (!players[pid].isEliminated) {
                    updates[`/players/${pid}/vote`] = null;
                    updates[`/players/${pid}/isCorrect`] = null;
                }
            });
            
            // Decidir si hay un evento especial
            let eventType = null;
            if (Math.random() < 0.25) { // 25% de probabilidad
                eventType = 'sudden_death';
            }
            updates['/specialEvent'] = eventType;

            updates['/state'] = 'round';
            updates['/currentRound'] = currentRound;
            updates['/currentPhrase'] = newPhrase;
            
            update(gameRef, updates);
        }

        // El Host revela las respuestas
        function revealAnswers() {
            const answer = gameState.currentPhrase.answer;
            const players = gameState.players || {};
            const updates = {};
            const isSuddenDeath = gameState.specialEvent === 'sudden_death';
            
            Object.keys(players).forEach(pid => {
                const player = players[pid];
                if (!player.isEliminated) {
                    const isCorrect = player.vote === answer;
                    updates[`/players/${pid}/isCorrect`] = isCorrect;
                    
                    if (!isCorrect) {
                        if (isSuddenDeath) {
                            updates[`/players/${pid}/lives`] = 0;
                            updates[`/players/${pid}/isEliminated`] = true;
                        } else {
                            const newLives = (player.lives ?? 2) - 1; // Default a 2 vidas si no existe
                            updates[`/players/${pid}/lives`] = newLives;
                            if (newLives <= 0) {
                                updates[`/players/${pid}/isEliminated`] = true;
                            }
                        }
                    }
                }
            });

            updates['/state'] = 'reveal';
            update(gameRef, updates);
        }

        // El Host termina el juego
        function triggerGameOver() {
            const players = Object.values(gameState.players || {});
            const survivors = players.filter(p => !p.isEliminated);
            const winnerName = survivors.length === 1 ? survivors[0].name : null;

            update(gameRef, {
                state: 'gameover',
                winner: winnerName || (survivors.length > 1 ? "Empate" : "Nadie")
            });
        }


        // --- LÓGICA DEL JUEGO (JUGADOR) ---

        function joinAsPlayer() {
            isHost = false;
            // Intentar recuperar el nombre, o pedirlo
            let name = localStorage.getItem('laPruebaPlayerName');
            if (!name) {
                name = prompt("Introduce tu nombre (corto):", "Jugador");
            }
            if (!name) return; // Canceló

            // Guardar nombre para reconexiones
            localStorage.setItem('laPruebaPlayerName', name); 

            console.log(`Uniéndose como Jugador: ${name}`);
            const playerRef = ref(db, `la-prueba/game/players/${localUserId}`); // Usa localUserId
            
            set(playerRef, {
                id: localUserId, // Usa localUserId
                name: name,
                lives: 2, // Empezar con 2 vidas
                isEliminated: false,
                vote: null,
                isCorrect: null
            });
            
            // Si el jugador cierra la pestaña, se elimina
            onDisconnect(playerRef).remove();
            
            setupPlayerListener();
        }

        function handleVote(vote) {
            // 'p' o 'r'
            update(ref(db, `la-prueba/game/players/${localUserId}`), { // Usa localUserId
                vote: vote
            });
            renderPlayerWait("Voto registrado.");
        }


        // --- LISTENERS (SINCRONIZACIÓN) ---

        // ==========================================================
        //         ¡¡¡INICIO DE LA CORRECCIÓN DE LÓGICA!!!
        // ==========================================================

        // ESTA ES LA FUNCIÓN DEL HOST (CORREGIDA)
        function setupHostListener() {
            onValue(gameRef, (snapshot) => {
                if (!snapshot.exists()) {
                    initGame(); // Si alguien borra la base, el host la recrea
                    return;
                }
                gameState = snapshot.val();
                
                // Si el juego existe pero no tiene la lista de frases (juego antiguo), reinícialo
                if (!gameState.shuffledPhrases) {
                    initGame();
                    return;
                }

                const { state, players = {}, currentPhrase, winner } = gameState;

                // --- ¡AQUÍ ESTÁ LA LÓGICA CLAVE DEL HOST! ---
                // Si un host se conecta y el juego ya está en "gameover" (de una
                // partida anterior), su primer trabajo es reiniciar y crear un nuevo lobby.
                if (state === 'gameover') {
                    // Esto pondrá el estado en 'lobby' y disparará este listener
                    // de nuevo, que luego renderizará el lobby correctamente.
                    console.log("Detectado estado 'gameover' al unirse como host. Reiniciando juego.");
                    initGame();
                    return; // No procesar el estado 'gameover'
                }

                // Esta es la lógica de renderizado del HOST (reemplaza la de jugador)
                switch (state) {
                    case 'lobby':
                        renderHostLobby(players);
                        break;
                    case 'round':
                        renderHostRound(currentPhrase, players);
                        break;
                    case 'reveal':
                        // Asegurarse de que currentPhrase exista
                        if(currentPhrase) {
                            renderHostReveal(currentPhrase, players, currentPhrase.answer);
                        } else {
                            // Si algo falla, volver al lobby
                            renderHostLobby(players);
                        }
                        break;
                    // El caso 'gameover' es manejado por el IF de arriba
                    default:
                        renderHostLobby(players);
                }
            });
        }

        // ESTA ES LA FUNCIÓN DEL JUGADOR (AÑADIDA)
        function setupPlayerListener() {
            onValue(gameRef, (snapshot) => {
                if (!snapshot.exists()) {
                    renderPlayerWait("Esperando a que el presentador inicie la sala...");
                    return;
                }
                gameState = snapshot.val();
                
                // Si el juego no tiene frases (aún no se ha inicializado), espera.
                if (!gameState.shuffledPhrases) {
                    renderPlayerWait("Conectando...");
                    return;
                }

                const { state, players = {}, currentPhrase, winner } = gameState;
                const myData = players[localUserId];

                // --- ¡AQUÍ ESTÁ LA LÓGICA CLAVE DEL JUGADOR! ---
                // Si el jugador se une y ve 'gameover', NO debe mostrar la pantalla
                // de fin de partida. Debe mostrar el lobby y esperar el reinicio.
                if (state === 'gameover') {
                    console.log("Detectado estado 'gameover' al unirse como jugador. Mostrando lobby.");
                    renderPlayerLobby(players); // Muestra el lobby, no la pantalla de gameover
                    return;
                }

                // Si mis datos no existen (p.ej. el host reinició el juego)
                if (!myData) {
                    // Si el juego está en el lobby (lo normal tras un reinicio),
                    // me vuelvo a unir automáticamente.
                    if (state === 'lobby') {
                        console.log("Juego reiniciado. Volviendo a unirse...");
                        const name = localStorage.getItem('laPruebaPlayerName');
                        if (name) {
                            const playerRef = ref(db, `la-prueba/game/players/${localUserId}`);
                            set(playerRef, {
                                id: localUserId,
                                name: name,
                                lives: 2,
                                isEliminated: false,
                                vote: null,
                                isCorrect: null
                            });
                            onDisconnect(playerRef).remove();
                        } else {
                            // Si no hay nombre guardado, volver al inicio
                            renderInitialScreen();
                        }
                    } else {
                        // Estado raro: no estoy y no es lobby. Mejor volver al inicio.
                         renderInitialScreen();
                    }
                    return; // El listener se disparará de nuevo cuando me una
                }

                // Si estoy eliminado, muestro la pantalla de eliminado
                if (myData.isEliminated) {
                    // A menos que el juego haya vuelto al lobby
                    if (state === 'lobby') {
                        renderPlayerLobby(players);
                    } else {
                        renderPlayerEliminated();
                    }
                    return;
                }

                // Lógica de renderizado del JUGADOR (no eliminado)
                switch (state) {
                    case 'lobby':
                        renderPlayerLobby(players);
                        break;
                    case 'round':
                        if (myData.vote) {
                            renderPlayerWait("Voto registrado.");
                        } else {
                            renderPlayerVote(currentPhrase);
                        }
                        break;
                    case 'reveal':
                        renderPlayerResult(myData.isCorrect, myData.lives);
                        break;
                    // 'gameover' ya fue manejado por el IF de arriba
                    default:
                        renderPlayerLobby(players);
                }
            });
        }
        main();

    </script>
</body>
</html>
