<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Â¿Pesimista o Realista?</title>
    <!-- Carga de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para el juego */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        .screen {
            display: none;
        }
        .screen.active {
            display: block;
        }
        /* AnimaciÃ³n de entrada */
        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Estilo para jugadores eliminados */
        .player-item.eliminated {
            text-decoration: line-through;
            opacity: 0.5;
        }
        /* Indicador de voto */
        .player-item.voted::after {
            content: 'âœ“';
            color: #10b981; /* Verde de Tailwind */
            font-weight: bold;
            margin-left: 8px;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex items-center justify-center p-4">

    <!-- Contenedor principal del juego -->
    <div id="app-container" class="w-full max-w-lg mx-auto bg-gray-800 rounded-xl shadow-2xl p-6 md:p-8">

        <!-- 1. Pantalla de Unirse (Join Screen) -->
        <div id="join-screen" class="screen active fade-in">
            <h1 class="text-3xl md:text-4xl font-black text-center mb-6">Â¿Pesimista o Realista?</h1>
            <p class="text-center text-gray-400 mb-8">Un juego de supervivencia social.</p>
            <div class="space-y-4">
                <input type="text" id="player-name" placeholder="Tu nombre" class="w-full p-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500" maxlength="15">
                <input type="text" id="game-id-input" placeholder="ID del Juego (para unirte)" class="w-full p-3 bg-gray-700 text-white rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-500" maxlength="5">
                <button id="join-button" class="w-full p-3 bg-purple-600 hover:bg-purple-700 rounded-lg font-bold text-lg transition-colors shadow-lg">Unirse al Juego</button>
                <button id="host-button" class="w-full p-3 bg-green-600 hover:bg-green-700 rounded-lg font-bold text-lg transition-colors shadow-lg">Crear Juego Nuevo</button>
            </div>
            <p id="join-error" class="text-red-400 text-center mt-4"></p>
        </div>

        <!-- 2. Pantalla de Espera (Lobby Screen) -->
        <div id="lobby-screen" class="screen">
            <h2 class="text-2xl font-bold text-center mb-4">Sala de Espera</h2>
            <div class="bg-gray-700 p-4 rounded-lg text-center mb-6">
                <p class="text-gray-400">Comparte este ID con tus amigos:</p>
                <span id="game-id-display" class="text-3xl font-black text-purple-300 tracking-widest">...</span>
            </div>
            <h3 class="font-bold text-lg mb-2">Jugadores Conectados:</h3>
            <ul id="lobby-player-list" class="bg-gray-700 rounded-lg p-4 space-y-2 min-h-[100px]">
                <!-- Jugadores se aÃ±adirÃ¡n aquÃ­ dinÃ¡micamente -->
            </ul>
            <button id="start-button" class="w-full p-3 bg-green-600 hover:bg-green-700 rounded-lg font-bold text-lg transition-colors mt-6 shadow-lg">Empezar Juego</button>
        </div>

        <!-- 3. Pantalla de Juego (Game Screen) -->
        <div id="game-screen" class="screen">
            <div id="round-info" class="text-center mb-4">
                <span class="text-xl font-bold text-purple-300">Ronda <span id="round-number">1</span></span>
                <div class="w-full bg-gray-600 rounded-full h-2.5 mt-2">
                    <div id="timer-bar" class="bg-purple-600 h-2.5 rounded-full transition-all duration-1000 linear"></div>
                </div>
            </div>

            <!-- Contenedor de la Frase -->
            <div id="phrase-container" class="bg-gray-700 p-6 rounded-lg min-h-[150px] flex items-center justify-center text-center mb-6 shadow-inner">
                <p id="phrase-text" class="text-xl md:text-2xl font-medium">...</p>
            </div>

            <!-- Contenedor de VotaciÃ³n -->
            <div id="vote-container">
                <p class="text-center text-gray-400 mb-4">Â¿QuÃ© es esta frase?</p>
                <div class="grid grid-cols-2 gap-4">
                    <button id="pessimist-button" class="p-4 bg-red-600 hover:bg-red-700 rounded-lg font-bold text-2xl transition-colors shadow-lg focus:outline-none focus:ring-2 focus:ring-red-400">Pesimista</button>
                    <button id="realist-button" class="p-4 bg-blue-600 hover:bg-blue-700 rounded-lg font-bold text-2xl transition-colors shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-400">Realista</button>
                </div>
            </div>

            <!-- Contenedor de Espera -->
            <div id="wait-container" class="text-center p-6 bg-gray-700 rounded-lg" style="display: none;">
                <p class="text-xl text-gray-400">Â¡Voto registrado! Esperando a los demÃ¡s...</p>
            </div>
        </div>

        <!-- 4. Pantalla de Resultados de Ronda -->
        <div id="results-screen" class="screen text-center">
            <h2 class="text-2xl font-bold mb-4">Resultados de la Ronda</h2>
            <p class="text-lg mb-2">La respuesta correcta era:</p>
            <span id="correct-answer" class="text-3xl font-black uppercase mb-6 block">...</span>
            <p id="elimination-info" class="text-xl text-red-400 font-bold mb-4">...</p>
            <p class="text-gray-400">Siguiente ronda en <span id="next-round-timer">5</span>...</p>
        </div>

        <!-- 5. Pantalla de Fin de Juego -->
        <div id="game-over-screen" class="screen text-center">
            <h2 class="text-4xl font-black mb-6">Â¡Juego Terminado!</h2>
            <p id="winner-info" class="text-2xl text-green-400 mb-8">...</p>
            <button id="play-again-button" class="w-full p-3 bg-purple-600 hover:bg-purple-700 rounded-lg font-bold text-lg transition-colors mt-6 shadow-lg">Jugar de Nuevo</button>
        </div>

        <!-- Lista de Jugadores (Visible siempre durante el juego) -->
        <div id="player-list-container" class="mt-6" style="display: none;">
            <h3 class="font-bold text-sm text-gray-400 mb-2 text-center uppercase tracking-wider">Jugadores</h3>
            <ul id="game-player-list" class="flex flex-wrap justify-center gap-2">
                <!-- Ejemplo: <li class="player-item bg-gray-700 p-2 px-3 rounded-full text-sm">Jugador 1</li> -->
            </ul>
        </div>
    </div>

    <!-- Script de Firebase -->
    <script type="module">
        // Importaciones de Firebase v9+
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-app.js";
        // SE HAN ELIMINADO LAS IMPORTACIONES DE AUTH
        import { getDatabase, ref, set, get, onValue, update, remove } from "https://www.gstatic.com/firebasejs/9.15.0/firebase-database.js";

        // CONFIGURACIÃ“N DE FIREBASE (proporcionada por el usuario)
        const firebaseConfig = {
            apiKey: "AIzaSyDrYwIMyL2y7yHXxQF4yjtokPOE2QyHC5I",
            authDomain: "pesimism-2fdad.firebaseapp.com",
            databaseURL: "https://pesimism-2fdad-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "pesimism-2fdad",
            storageBucket: "pesimism-2fdad.firebasestorage.app",
            messagingSenderId: "859660712236",
            appId: "1:859660712236:web:e09ac663d189f550d2d489",
            measurementId: "G-TYE4V0P8XB"
        };

        // BASE DE DATOS DE FRASES
        const PHRASE_LIST = [
            { text: "Todo va a salir mal.", type: "pesimista" },
            { text: "No tiene sentido intentarlo, fracasarÃ© de todos modos.", type: "pesimista" },
            { text: "A veces las cosas no salen como planeas.", type: "realista" },
            { text: "El Ã©xito requiere esfuerzo y asumir la posibilidad de fallar.", type: "realista" },
            { text: "Nunca se puede confiar en nadie.", type: "pesimista" },
            { text: "Es prudente ser cauteloso con en quiÃ©n confÃ­as plenamente.", type: "realista" },
            { text: "La felicidad es solo una ilusiÃ³n temporal.", type: "pesimista" },
            { text: "La felicidad es un estado emocional que fluctÃºa.", type: "realista" },
            { text: "El futuro es incierto y probablemente peor.", type: "pesimista" },
            { text: "El futuro es incierto y no se puede predecir.", type: "realista" },
            { text: "Da igual lo que hagas, el resultado serÃ¡ el mismo.", type: "pesimista" },
            { text: "No siempre puedes controlar el resultado, solo tu esfuerzo.", type: "realista" },
            { text: "La mayorÃ­a de la gente solo se preocupa por sÃ­ misma.", type: "realista" }, // Ambiguo
            { text: "Todo el mundo es fundamentalmente egoÃ­sta.", type: "pesimista" },
            { text: "No hay nada bueno en el mundo.", type: "pesimista" },
            { text: "El mundo tiene problemas significativos que deben abordarse.", type: "realista" },
            { text: "Siempre acabarÃ¡s solo.", type: "pesimista" },
            { text: "Las relaciones requieren trabajo y no todas duran para siempre.", type: "realista" },
            { text: "Planificar es inÃºtil porque todo se tuerce.", type: "pesimista" },
            { text: "Los planes deben ser flexibles para adaptarse a imprevistos.", type: "realista" }
        ];

        // Inicializar Firebase
        const app = initializeApp(firebaseConfig);
        // SE HA ELIMINADO LA INICIALIZACIÃ“N DE AUTH
        const db = getDatabase(app);

        // --- MANEJO DE ID DE USUARIO LOCAL ---
        // Se crea un ID local si no existe en la sesiÃ³n
        function getOrCreateLocalUserId() {
            let uid = sessionStorage.getItem('pesimistaGameUserId');
            if (!uid) {
                uid = Math.random().toString(36).substring(2, 12); // Un ID aleatorio simple
                sessionStorage.setItem('pesimistaGameUserId', uid);
            }
            return uid;
        }

        // Variables de estado del juego
        let localUserId = getOrCreateLocalUserId(); // ID de usuario local en lugar de currentUser
        let currentGameId = null;
        let isHost = false;
        let localGameState = null;
        let gameTimerInterval = null;
        const ROUND_TIME = 15; // segundos
        const RESULTS_TIME = 5; // segundos

        // Referencias a elementos del DOM
        const screens = {
            join: document.getElementById('join-screen'),
            lobby: document.getElementById('lobby-screen'),
            game: document.getElementById('game-screen'),
            results: document.getElementById('results-screen'),
            gameOver: document.getElementById('game-over-screen')
        };
        const playerNameInput = document.getElementById('player-name');
        const gameIdInput = document.getElementById('game-id-input');
        const joinButton = document.getElementById('join-button');
        const hostButton = document.getElementById('host-button');
        const joinError = document.getElementById('join-error');
        const gameIdDisplay = document.getElementById('game-id-display');
        const lobbyPlayerList = document.getElementById('lobby-player-list');
        const startButton = document.getElementById('start-button');
        const playerListContainer = document.getElementById('player-list-container');
        const gamePlayerList = document.getElementById('game-player-list');
        const roundNumber = document.getElementById('round-number');
        const timerBar = document.getElementById('timer-bar');
        const phraseText = document.getElementById('phrase-text');
        const voteContainer = document.getElementById('vote-container');
        const waitContainer = document.getElementById('wait-container');
        const pessimistButton = document.getElementById('pessimist-button');
        const realistButton = document.getElementById('realist-button');
        const correctAnswer = document.getElementById('correct-answer');
        const eliminationInfo = document.getElementById('elimination-info');
        const nextRoundTimer = document.getElementById('next-round-timer');
        const winnerInfo = document.getElementById('winner-info');
        const playAgainButton = document.getElementById('play-again-button');

        // --- AUTENTICACIÃ“N ---
        // SE HA ELIMINADO TODA LA LÃ“GICA DE AUTH (signInAnonymously, onAuthStateChanged)

        // --- NAVEGACIÃ“N DE PANTALLAS ---

        function showScreen(screenName) {
            Object.values(screens).forEach(screen => screen.classList.remove('active'));
            if (screens[screenName]) {
                screens[screenName].classList.add('active');
            }
            // Mostrar lista de jugadores persistente durante el juego
            if (['game', 'results', 'gameOver'].includes(screenName)) {
                playerListContainer.style.display = 'block';
            } else {
                playerListContainer.style.display = 'none';
            }
        }

        // --- LÃ“GICA DE UNIRSE Y CREAR JUEGO ---

        hostButton.onclick = async () => {
            // El host ya no necesita nombre, solo crea la partida.
            if (!localUserId) {
                joinError.textContent = "Error de autenticaciÃ³n. IntÃ©ntalo de nuevo.";
                return;
            }

            isHost = true;
            currentGameId = Math.random().toString(36).substring(2, 7).toUpperCase();
            
            const gameRef = ref(db, `games/${currentGameId}`);
            
            const initialGameState = {
                status: 'lobby',
                hostId: localUserId, // Se usa localUserId
                players: {} // El host no es un jugador, la lista empieza vacÃ­a.
            };
            
            await set(gameRef, initialGameState);
            listenToGame(currentGameId);
        };

        joinButton.onclick = async () => {
            const name = playerNameInput.value.trim();
            const gameId = gameIdInput.value.trim().toUpperCase();

            if (!name) {
                joinError.textContent = "Por favor, introduce tu nombre.";
                return;
            }
            if (!gameId) {
                joinError.textContent = "Por favor, introduce un ID de juego.";
                return;
            }
            // ComprobaciÃ³n de localUserId en lugar de currentUser
            if (!localUserId) {
                joinError.textContent = "Error de autenticaciÃ³n. IntÃ©ntalo de nuevo.";
                return;
            }

            const gameRef = ref(db, `games/${gameId}`);
            const snapshot = await get(gameRef);

            if (!snapshot.exists()) {
                joinError.textContent = "Juego no encontrado.";
                return;
            }

            const gameData = snapshot.val();

            // AÃ±adida comprobaciÃ³n de estado
            if (gameData.status !== 'lobby') {
                joinError.textContent = "Este juego ya ha comenzado.";
                return;
            }

            const playerRef = ref(db, `games/${gameId}/players/${localUserId}`); // Se usa localUserId
            await set(playerRef, {
                name: name,
                isEliminated: false,
                vote: null
            });

            currentGameId = gameId;
            isHost = false; // Solo el creador es host
            listenToGame(gameId);
        };

        // --- LISTENER PRINCIPAL DEL JUEGO ---

        function listenToGame(gameId) {
            const gameRef = ref(db, `games/${gameId}`);
            onValue(gameRef, (snapshot) => {
                const state = snapshot.val();
                if (!state) {
                    // El juego fue borrado (quizÃ¡s el host se fue)
                    // Se elimina alert() y se usa un mÃ©todo mÃ¡s limpio
                    console.log("El juego ha terminado o fue borrado por el host.");
                    showScreen('join'); // Vuelve a la pantalla de inicio
                    // Resetea el estado local
                    currentGameId = null;
                    isHost = false;
                    localGameState = null;
                    if(gameTimerInterval) {
                        clearInterval(gameTimerInterval);
                        gameTimerInterval = null;
                    }
                    joinError.textContent = "El juego ha terminado o fue borrado.";
                    return;
                }
                
                localGameState = state; // Actualizar estado local
                updateUI(state);

                // El host maneja la lÃ³gica del juego
                if (isHost && localUserId === state.hostId) { // Se usa localUserId
                    handleHostLogic(state);
                }
            });
        }

        // --- ACTUALIZACIÃ“N DE LA UI ---

        function updateUI(state) {
            const players = state.players || {};
            const playerArray = Object.entries(players).map(([id, data]) => ({ id, ...data }));
            
            // Actualizar estado de pantalla
            if (state.status === 'lobby') {
                showScreen('lobby');
                gameIdDisplay.textContent = currentGameId;
                lobbyPlayerList.innerHTML = playerArray.map(p => `<li class="p-2">${p.name} ${state.hostId === p.id ? 'ðŸ‘‘' : ''}</li>`).join('');
                startButton.style.display = (isHost && playerArray.length > 0) ? 'block' : 'none';
            
            } else if (state.status === 'playing') {
                if (state.showResults) {
                    showScreen('results');
                    correctAnswer.textContent = state.currentPhrase.type;
                    nextRoundTimer.textContent = state.timer;
                    
                    const eliminatedThisRound = playerArray.filter(p => p.justEliminated);
                    if (eliminatedThisRound.length > 0) {
                        eliminationInfo.textContent = `Eliminados: ${eliminatedThisRound.map(p => p.name).join(', ')}`;
                    } else {
                        eliminationInfo.textContent = "Â¡Nadie fue eliminado esta ronda!";
                    }

                } else {
                    showScreen('game');
                    roundNumber.textContent = state.currentRound;
                    phraseText.textContent = state.currentPhrase.text;
                    
                    // Barra de tiempo
                    const timerPercentage = (state.timer / ROUND_TIME) * 100;
                    timerBar.style.width = `${timerPercentage}%`;

                    // LÃ³gica de votaciÃ³n (diferente para Host y Jugadores)
                    const myData = players[localUserId]; // Se usa localUserId

                    if (isHost) {
                        // El Host (proyector) no vota, solo observa.
                        voteContainer.style.display = 'none';
                        waitContainer.style.display = 'block';
                        waitContainer.firstElementChild.textContent = "Partida en curso... Esperando votos.";
                    
                    } else if (myData) { // Comprobar si myData existe (es un jugador)
                        if (myData.isEliminated) {
                            voteContainer.style.display = 'none';
                            waitContainer.style.display = 'block';
                            waitContainer.firstElementChild.textContent = "Has sido eliminado. Esperando...";
                        } else if (myData.vote) {
                            voteContainer.style.display = 'none';
                            waitContainer.style.display = 'block';
                            waitContainer.firstElementChild.textContent = "Â¡Voto registrado! Esperando...";
                        } else {
                            voteContainer.style.display = 'block';
                            waitContainer.style.display = 'none';
                        }
                    } else {
                        // Es un espectador o alguien que no se uniÃ³ a tiempo
                        voteContainer.style.display = 'none';
                        waitContainer.style.display = 'block';
                        waitContainer.firstElementChild.textContent = "Observando...";
                    }
                }

            } else if (state.status === 'finished') {
                showScreen('gameOver');
                const activePlayers = playerArray.filter(p => !p.isEliminated);
                if (activePlayers.length === 1) {
                    winnerInfo.textContent = `Â¡El ganador es ${activePlayers[0].name}!`;
                } else {
                    winnerInfo.textContent = "Â¡Es un empate!";
                }
                playAgainButton.style.display = isHost ? 'block' : 'none';
            }

            // Actualizar lista de jugadores persistente
            gamePlayerList.innerHTML = playerArray.map(p => {
                let classes = "player-item p-2 px-3 rounded-full text-sm transition-all";
                classes += p.isEliminated ? " eliminated bg-gray-600" : " bg-gray-700";
                classes += (state.showResults && p.vote && !p.isEliminated) ? (p.vote === state.currentPhrase.type ? " border-2 border-green-500" : " border-2 border-red-500") : "";
                classes += (!state.showResults && p.vote && !p.isEliminated) ? " voted" : "";
                return `<li class="${classes}">${p.name}</li>`;
            }).join('');
        }

        // --- LÃ“GICA DEL HOST (MANEJO DEL JUEGO) ---

        startButton.onclick = () => {
            if (!isHost) return;

            const shuffledPhrases = [...PHRASE_LIST].sort(() => Math.random() - 0.5);
            const initialPlayers = { ...localGameState.players };
            Object.keys(initialPlayers).forEach(id => {
                initialPlayers[id].isEliminated = false;
                initialPlayers[id].vote = null;
            });

            const gameRef = ref(db, `games/${currentGameId}`);
            update(gameRef, {
                status: 'playing',
                currentRound: 1,
                phrases: shuffledPhrases,
                currentPhrase: shuffledPhrases[0],
                timer: ROUND_TIME,
                showResults: false,
                players: initialPlayers
            });
        };

        function handleHostLogic(state) {
            // Iniciar o detener el temporizador
            // Cambiado de setInterval a una lÃ³gica de setTimeout recursivo
            if (state.status === 'playing' && !gameTimerInterval) { 
                // No hay un tick programado, y el juego estÃ¡ en marcha.
                // Â¡Iniciemos el bucle!
                handleGameTick(); 
            } else if (state.status !== 'playing' && gameTimerInterval) {
                // El juego no estÃ¡ en marcha, pero hay un tick programado.
                // Â¡CancelÃ©moslo!
                clearTimeout(gameTimerInterval);
                gameTimerInterval = null;
            }
            // Si el juego estÃ¡ en marcha y ya hay un tick programado, no hacer nada.
            // El bucle se autogestiona.
        }

        async function handleGameTick() {
            // Primero, borramos el ID del timer actual,
            // porque este tick se estÃ¡ ejecutando AHORA.
            gameTimerInterval = null; 

            // ComprobaciÃ³n de seguridad: Â¿deberÃ­amos seguir corriendo?
            if (!isHost || !localGameState || localGameState.status !== 'playing') {
                return; // Detener el bucle
            }

            // LÃ³gica del tick
            const gameRef = ref(db, `games/${currentGameId}`);
            let newTimer = localGameState.timer - 1;

            if (localGameState.showResults) {
                // Estamos en la pantalla de resultados
                if (newTimer <= 0) {
                    // Pasar a la siguiente ronda
                    await nextRound();
                } else {
                    await update(gameRef, { timer: newTimer });
                }
            } else {
                // Estamos en la pantalla de votaciÃ³n
                const players = localGameState.players || {};
                const activePlayers = Object.values(players).filter(p => !p.isEliminated);
                const allVoted = activePlayers.every(p => p.vote !== null);

                if (newTimer <= 0 || allVoted) {
                    // Calcular resultados
                    await calculateResults();
                } else {
                    await update(gameRef, { timer: newTimer });
                }
            }

            // Al final, volvemos a programar el siguiente tick SI es necesario
            // onValue actualizarÃ¡ localGameState, asÃ­ que leemos el estado MÃS RECIENTE
            // de la base de datos (que estÃ¡ en localGameState despuÃ©s del await).
            if (localGameState.status === 'playing') {
                gameTimerInterval = setTimeout(handleGameTick, 1000);
            }
            // Si el estado cambiÃ³ a 'finished' (por calculateResults o nextRound),
            // gameTimerInterval seguirÃ¡ siendo null, y el bucle se detiene.
        }

        async function calculateResults() {
            const state = localGameState;
            const players = { ...state.players };
            const correctAnswer = state.currentPhrase.type;
            let eliminatedCount = 0;
            
            const activePlayerIds = Object.keys(players).filter(id => !players[id].isEliminated);
            const wrongPlayerIds = activePlayerIds.filter(id => players[id].vote !== correctAnswer && players[id].vote !== null);
            
            // LÃ³gica de eliminaciÃ³n: no eliminar si todos aciertan o todos fallan
            if (wrongPlayerIds.length > 0 && wrongPlayerIds.length < activePlayerIds.length) {
                eliminatedCount = wrongPlayerIds.length;
                wrongPlayerIds.forEach(id => {
                    players[id].isEliminated = true;
                    players[id].justEliminated = true; // Flag temporal
                });
            }

            // Limpiar flags temporales
            Object.keys(players).forEach(id => {
                if (!wrongPlayerIds.includes(id)) {
                    players[id].justEliminated = false;
                }
            });

            const activePlayersLeft = activePlayerIds.length - eliminatedCount;
            let newStatus = 'playing';
            if (activePlayersLeft <= 1) {
                newStatus = 'finished';
            }

            await update(ref(db, `games/${currentGameId}`), {
                status: newStatus,
                showResults: true,
                timer: RESULTS_TIME,
                players: players
            });
        }

        async function nextRound() {
            const state = localGameState;
            const newRound = state.currentRound + 1;
            
            if (newRound > state.phrases.length || state.status === 'finished') {
                await update(ref(db, `games/${currentGameId}`), { status: 'finished' });
                return;
            }

            const players = { ...state.players };
            Object.keys(players).forEach(id => {
                players[id].vote = null; // Resetear votos
                players[id].justEliminated = false; // Limpiar flag
            });

            await update(ref(db, `games/${currentGameId}`), {
                currentRound: newRound,
                currentPhrase: state.phrases[newRound - 1],
                timer: ROUND_TIME,
                showResults: false,
                players: players
            });
        }

        // --- ACCIONES DEL JUGADOR ---

        pessimistButton.onclick = () => submitVote('pesimista');
        realistButton.onclick = () => submitVote('realista');

        function submitVote(vote) {
            if (!currentGameId || !localUserId) return; // Se usa localUserId
            const myData = localGameState.players[localUserId]; // Se usa localUserId
            if (myData.isEliminated || myData.vote) return; // No votar si ya votÃ³ o estÃ¡ eliminado

            const voteRef = ref(db, `games/${currentGameId}/players/${localUserId}/vote`); // Se usa localUserId
            set(voteRef, vote);
        }
 
        // --- FIN DEL JUEGO / REINICIAR ---

        playAgainButton.onclick = async () => {
            if (!isHost) return;
            
            // Resetear el estado del juego a la sala de espera
            const players = { ...localGameState.players };
            Object.keys(players).forEach(id => {
                players[id].isEliminated = false;
                players[id].vote = null;
            });

            await set(ref(db, `games/${currentGameId}`), {
                status: 'lobby',
                hostId: localUserId, // <-- ERROR CORREGIDO: de currentUser.uid a localUserId
                players: players
            });
        };

        // Limpieza al cerrar la pestaÃ±a (opcional pero bueno)
        window.addEventListener('beforeunload', () => {
            if (!currentGameId || !localUserId) return; // Se usa localUserId

            const playerRef = ref(db, `games/${currentGameId}/players/${localUserId}`); // Se usa localUserId
            remove(playerRef); // Quitar al jugador

            if (isHost) {
                // Si el host se va, borrar el juego
                const gameRef = ref(db, `games/${currentGameId}`);
                remove(gameRef);
            }
        });

    </script>
</body>
</html>
